#include <immintrin.h>
#include <cstdint>
#include <array>
#include <map>
#include <stack>
#include <iostream>
#include <iomanip>
#include <sstream>
#include "uci.h"
#include "types.h"
#include "piece.h"
#include "position.h"

using namespace std;

__m256i rook_mask[256] =
{
    // Quadrant 1.
    {0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    // Quadrant 2.
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    // Quadrant 3.
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    // Quadrant 4.
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
    {0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},{0x0,0x0,0x0,0x0},
};

/*
uint8_t sbox[256] = {
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

uint32_t pbox32[256] =
{
0x00000000,
0x00000008,
0x00000080,
0x00000088,
0x00000800,
0x00000808,
0x00000880,
0x00000888,
0x00008000,
0x00008008,
0x00008080,
0x00008088,
0x00008800,
0x00008808,
0x00008880,
0x00008888,
0x00080000,
0x00080008,
0x00080080,
0x00080088,
0x00080800,
0x00080808,
0x00080880,
0x00080888,
0x00088000,
0x00088008,
0x00088080,
0x00088088,
0x00088800,
0x00088808,
0x00088880,
0x00088888,
0x00800000,
0x00800008,
0x00800080,
0x00800088,
0x00800800,
0x00800808,
0x00800880,
0x00800888,
0x00808000,
0x00808008,
0x00808080,
0x00808088,
0x00808800,
0x00808808,
0x00808880,
0x00808888,
0x00880000,
0x00880008,
0x00880080,
0x00880088,
0x00880800,
0x00880808,
0x00880880,
0x00880888,
0x00888000,
0x00888008,
0x00888080,
0x00888088,
0x00888800,
0x00888808,
0x00888880,
0x00888888,
0x08000000,
0x08000008,
0x08000080,
0x08000088,
0x08000800,
0x08000808,
0x08000880,
0x08000888,
0x08008000,
0x08008008,
0x08008080,
0x08008088,
0x08008800,
0x08008808,
0x08008880,
0x08008888,
0x08080000,
0x08080008,
0x08080080,
0x08080088,
0x08080800,
0x08080808,
0x08080880,
0x08080888,
0x08088000,
0x08088008,
0x08088080,
0x08088088,
0x08088800,
0x08088808,
0x08088880,
0x08088888,
0x08800000,
0x08800008,
0x08800080,
0x08800088,
0x08800800,
0x08800808,
0x08800880,
0x08800888,
0x08808000,
0x08808008,
0x08808080,
0x08808088,
0x08808800,
0x08808808,
0x08808880,
0x08808888,
0x08880000,
0x08880008,
0x08880080,
0x08880088,
0x08880800,
0x08880808,
0x08880880,
0x08880888,
0x08888000,
0x08888008,
0x08888080,
0x08888088,
0x08888800,
0x08888808,
0x08888880,
0x08888888,
0x80000000,
0x80000008,
0x80000080,
0x80000088,
0x80000800,
0x80000808,
0x80000880,
0x80000888,
0x80008000,
0x80008008,
0x80008080,
0x80008088,
0x80008800,
0x80008808,
0x80008880,
0x80008888,
0x80080000,
0x80080008,
0x80080080,
0x80080088,
0x80080800,
0x80080808,
0x80080880,
0x80080888,
0x80088000,
0x80088008,
0x80088080,
0x80088088,
0x80088800,
0x80088808,
0x80088880,
0x80088888,
0x80800000,
0x80800008,
0x80800080,
0x80800088,
0x80800800,
0x80800808,
0x80800880,
0x80800888,
0x80808000,
0x80808008,
0x80808080,
0x80808088,
0x80808800,
0x80808808,
0x80808880,
0x80808888,
0x80880000,
0x80880008,
0x80880080,
0x80880088,
0x80880800,
0x80880808,
0x80880880,
0x80880888,
0x80888000,
0x80888008,
0x80888080,
0x80888088,
0x80888800,
0x80888808,
0x80888880,
0x80888888,
0x88000000,
0x88000008,
0x88000080,
0x88000088,
0x88000800,
0x88000808,
0x88000880,
0x88000888,
0x88008000,
0x88008008,
0x88008080,
0x88008088,
0x88008800,
0x88008808,
0x88008880,
0x88008888,
0x88080000,
0x88080008,
0x88080080,
0x88080088,
0x88080800,
0x88080808,
0x88080880,
0x88080888,
0x88088000,
0x88088008,
0x88088080,
0x88088088,
0x88088800,
0x88088808,
0x88088880,
0x88088888,
0x88800000,
0x88800008,
0x88800080,
0x88800088,
0x88800800,
0x88800808,
0x88800880,
0x88800888,
0x88808000,
0x88808008,
0x88808080,
0x88808088,
0x88808800,
0x88808808,
0x88808880,
0x88808888,
0x88880000,
0x88880008,
0x88880080,
0x88880088,
0x88880800,
0x88880808,
0x88880880,
0x88880888,
0x88888000,
0x88888008,
0x88888080,
0x88888088,
0x88888800,
0x88888808,
0x88888880,
0x88888888,
};

uint64_t pbox64[256] =
{
0x0000000000000000,
0x0000000000000080,
0x0000000000008000,
0x0000000000008080,
0x0000000000800000,
0x0000000000800080,
0x0000000000808000,
0x0000000000808080,
0x0000000080000000,
0x0000000080000080,
0x0000000080008000,
0x0000000080008080,
0x0000000080800000,
0x0000000080800080,
0x0000000080808000,
0x0000000080808080,
0x0000008000000000,
0x0000008000000080,
0x0000008000008000,
0x0000008000008080,
0x0000008000800000,
0x0000008000800080,
0x0000008000808000,
0x0000008000808080,
0x0000008080000000,
0x0000008080000080,
0x0000008080008000,
0x0000008080008080,
0x0000008080800000,
0x0000008080800080,
0x0000008080808000,
0x0000008080808080,
0x0000800000000000,
0x0000800000000080,
0x0000800000008000,
0x0000800000008080,
0x0000800000800000,
0x0000800000800080,
0x0000800000808000,
0x0000800000808080,
0x0000800080000000,
0x0000800080000080,
0x0000800080008000,
0x0000800080008080,
0x0000800080800000,
0x0000800080800080,
0x0000800080808000,
0x0000800080808080,
0x0000808000000000,
0x0000808000000080,
0x0000808000008000,
0x0000808000008080,
0x0000808000800000,
0x0000808000800080,
0x0000808000808000,
0x0000808000808080,
0x0000808080000000,
0x0000808080000080,
0x0000808080008000,
0x0000808080008080,
0x0000808080800000,
0x0000808080800080,
0x0000808080808000,
0x0000808080808080,
0x0080000000000000,
0x0080000000000080,
0x0080000000008000,
0x0080000000008080,
0x0080000000800000,
0x0080000000800080,
0x0080000000808000,
0x0080000000808080,
0x0080000080000000,
0x0080000080000080,
0x0080000080008000,
0x0080000080008080,
0x0080000080800000,
0x0080000080800080,
0x0080000080808000,
0x0080000080808080,
0x0080008000000000,
0x0080008000000080,
0x0080008000008000,
0x0080008000008080,
0x0080008000800000,
0x0080008000800080,
0x0080008000808000,
0x0080008000808080,
0x0080008080000000,
0x0080008080000080,
0x0080008080008000,
0x0080008080008080,
0x0080008080800000,
0x0080008080800080,
0x0080008080808000,
0x0080008080808080,
0x0080800000000000,
0x0080800000000080,
0x0080800000008000,
0x0080800000008080,
0x0080800000800000,
0x0080800000800080,
0x0080800000808000,
0x0080800000808080,
0x0080800080000000,
0x0080800080000080,
0x0080800080008000,
0x0080800080008080,
0x0080800080800000,
0x0080800080800080,
0x0080800080808000,
0x0080800080808080,
0x0080808000000000,
0x0080808000000080,
0x0080808000008000,
0x0080808000008080,
0x0080808000800000,
0x0080808000800080,
0x0080808000808000,
0x0080808000808080,
0x0080808080000000,
0x0080808080000080,
0x0080808080008000,
0x0080808080008080,
0x0080808080800000,
0x0080808080800080,
0x0080808080808000,
0x0080808080808080,
0x8000000000000000,
0x8000000000000080,
0x8000000000008000,
0x8000000000008080,
0x8000000000800000,
0x8000000000800080,
0x8000000000808000,
0x8000000000808080,
0x8000000080000000,
0x8000000080000080,
0x8000000080008000,
0x8000000080008080,
0x8000000080800000,
0x8000000080800080,
0x8000000080808000,
0x8000000080808080,
0x8000008000000000,
0x8000008000000080,
0x8000008000008000,
0x8000008000008080,
0x8000008000800000,
0x8000008000800080,
0x8000008000808000,
0x8000008000808080,
0x8000008080000000,
0x8000008080000080,
0x8000008080008000,
0x8000008080008080,
0x8000008080800000,
0x8000008080800080,
0x8000008080808000,
0x8000008080808080,
0x8000800000000000,
0x8000800000000080,
0x8000800000008000,
0x8000800000008080,
0x8000800000800000,
0x8000800000800080,
0x8000800000808000,
0x8000800000808080,
0x8000800080000000,
0x8000800080000080,
0x8000800080008000,
0x8000800080008080,
0x8000800080800000,
0x8000800080800080,
0x8000800080808000,
0x8000800080808080,
0x8000808000000000,
0x8000808000000080,
0x8000808000008000,
0x8000808000008080,
0x8000808000800000,
0x8000808000800080,
0x8000808000808000,
0x8000808000808080,
0x8000808080000000,
0x8000808080000080,
0x8000808080008000,
0x8000808080008080,
0x8000808080800000,
0x8000808080800080,
0x8000808080808000,
0x8000808080808080,
0x8080000000000000,
0x8080000000000080,
0x8080000000008000,
0x8080000000008080,
0x8080000000800000,
0x8080000000800080,
0x8080000000808000,
0x8080000000808080,
0x8080000080000000,
0x8080000080000080,
0x8080000080008000,
0x8080000080008080,
0x8080000080800000,
0x8080000080800080,
0x8080000080808000,
0x8080000080808080,
0x8080008000000000,
0x8080008000000080,
0x8080008000008000,
0x8080008000008080,
0x8080008000800000,
0x8080008000800080,
0x8080008000808000,
0x8080008000808080,
0x8080008080000000,
0x8080008080000080,
0x8080008080008000,
0x8080008080008080,
0x8080008080800000,
0x8080008080800080,
0x8080008080808000,
0x8080008080808080,
0x8080800000000000,
0x8080800000000080,
0x8080800000008000,
0x8080800000008080,
0x8080800000800000,
0x8080800000800080,
0x8080800000808000,
0x8080800000808080,
0x8080800080000000,
0x8080800080000080,
0x8080800080008000,
0x8080800080008080,
0x8080800080800000,
0x8080800080800080,
0x8080800080808000,
0x8080800080808080,
0x8080808000000000,
0x8080808000000080,
0x8080808000008000,
0x8080808000008080,
0x8080808000800000,
0x8080808000800080,
0x8080808000808000,
0x8080808000808080,
0x8080808080000000,
0x8080808080000080,
0x8080808080008000,
0x8080808080008080,
0x8080808080800000,
0x8080808080800080,
0x8080808080808000,
0x8080808080808080,
};

uint64_t pbox128[2][256] =
{
0x0000000000000000,0x0000000000000000,
0x0000000000000000,0x0000000000008000,
0x0000000000000000,0x0000000080000000,
0x0000000000000000,0x0000000080008000,
0x0000000000000000,0x0000800000000000,
0x0000000000000000,0x0000800000008000,
0x0000000000000000,0x0000800080000000,
0x0000000000000000,0x0000800080008000,
0x0000000000000000,0x8000000000000000,
0x0000000000000000,0x8000000000008000,
0x0000000000000000,0x8000000080000000,
0x0000000000000000,0x8000000080008000,
0x0000000000000000,0x8000800000000000,
0x0000000000000000,0x8000800000008000,
0x0000000000000000,0x8000800080000000,
0x0000000000000000,0x8000800080008000,
0x0000000000008000,0x0000000000000000,
0x0000000000008000,0x0000000000008000,
0x0000000000008000,0x0000000080000000,
0x0000000000008000,0x0000000080008000,
0x0000000000008000,0x0000800000000000,
0x0000000000008000,0x0000800000008000,
0x0000000000008000,0x0000800080000000,
0x0000000000008000,0x0000800080008000,
0x0000000000008000,0x8000000000000000,
0x0000000000008000,0x8000000000008000,
0x0000000000008000,0x8000000080000000,
0x0000000000008000,0x8000000080008000,
0x0000000000008000,0x8000800000000000,
0x0000000000008000,0x8000800000008000,
0x0000000000008000,0x8000800080000000,
0x0000000000008000,0x8000800080008000,
0x0000000080000000,0x0000000000000000,
0x0000000080000000,0x0000000000008000,
0x0000000080000000,0x0000000080000000,
0x0000000080000000,0x0000000080008000,
0x0000000080000000,0x0000800000000000,
0x0000000080000000,0x0000800000008000,
0x0000000080000000,0x0000800080000000,
0x0000000080000000,0x0000800080008000,
0x0000000080000000,0x8000000000000000,
0x0000000080000000,0x8000000000008000,
0x0000000080000000,0x8000000080000000,
0x0000000080000000,0x8000000080008000,
0x0000000080000000,0x8000800000000000,
0x0000000080000000,0x8000800000008000,
0x0000000080000000,0x8000800080000000,
0x0000000080000000,0x8000800080008000,
0x0000000080008000,0x0000000000000000,
0x0000000080008000,0x0000000000008000,
0x0000000080008000,0x0000000080000000,
0x0000000080008000,0x0000000080008000,
0x0000000080008000,0x0000800000000000,
0x0000000080008000,0x0000800000008000,
0x0000000080008000,0x0000800080000000,
0x0000000080008000,0x0000800080008000,
0x0000000080008000,0x8000000000000000,
0x0000000080008000,0x8000000000008000,
0x0000000080008000,0x8000000080000000,
0x0000000080008000,0x8000000080008000,
0x0000000080008000,0x8000800000000000,
0x0000000080008000,0x8000800000008000,
0x0000000080008000,0x8000800080000000,
0x0000000080008000,0x8000800080008000,
0x0000800000000000,0x0000000000000000,
0x0000800000000000,0x0000000000008000,
0x0000800000000000,0x0000000080000000,
0x0000800000000000,0x0000000080008000,
0x0000800000000000,0x0000800000000000,
0x0000800000000000,0x0000800000008000,
0x0000800000000000,0x0000800080000000,
0x0000800000000000,0x0000800080008000,
0x0000800000000000,0x8000000000000000,
0x0000800000000000,0x8000000000008000,
0x0000800000000000,0x8000000080000000,
0x0000800000000000,0x8000000080008000,
0x0000800000000000,0x8000800000000000,
0x0000800000000000,0x8000800000008000,
0x0000800000000000,0x8000800080000000,
0x0000800000000000,0x8000800080008000,
0x0000800000008000,0x0000000000000000,
0x0000800000008000,0x0000000000008000,
0x0000800000008000,0x0000000080000000,
0x0000800000008000,0x0000000080008000,
0x0000800000008000,0x0000800000000000,
0x0000800000008000,0x0000800000008000,
0x0000800000008000,0x0000800080000000,
0x0000800000008000,0x0000800080008000,
0x0000800000008000,0x8000000000000000,
0x0000800000008000,0x8000000000008000,
0x0000800000008000,0x8000000080000000,
0x0000800000008000,0x8000000080008000,
0x0000800000008000,0x8000800000000000,
0x0000800000008000,0x8000800000008000,
0x0000800000008000,0x8000800080000000,
0x0000800000008000,0x8000800080008000,
0x0000800080000000,0x0000000000000000,
0x0000800080000000,0x0000000000008000,
0x0000800080000000,0x0000000080000000,
0x0000800080000000,0x0000000080008000,
0x0000800080000000,0x0000800000000000,
0x0000800080000000,0x0000800000008000,
0x0000800080000000,0x0000800080000000,
0x0000800080000000,0x0000800080008000,
0x0000800080000000,0x8000000000000000,
0x0000800080000000,0x8000000000008000,
0x0000800080000000,0x8000000080000000,
0x0000800080000000,0x8000000080008000,
0x0000800080000000,0x8000800000000000,
0x0000800080000000,0x8000800000008000,
0x0000800080000000,0x8000800080000000,
0x0000800080000000,0x8000800080008000,
0x0000800080008000,0x0000000000000000,
0x0000800080008000,0x0000000000008000,
0x0000800080008000,0x0000000080000000,
0x0000800080008000,0x0000000080008000,
0x0000800080008000,0x0000800000000000,
0x0000800080008000,0x0000800000008000,
0x0000800080008000,0x0000800080000000,
0x0000800080008000,0x0000800080008000,
0x0000800080008000,0x8000000000000000,
0x0000800080008000,0x8000000000008000,
0x0000800080008000,0x8000000080000000,
0x0000800080008000,0x8000000080008000,
0x0000800080008000,0x8000800000000000,
0x0000800080008000,0x8000800000008000,
0x0000800080008000,0x8000800080000000,
0x0000800080008000,0x8000800080008000,
0x8000000000000000,0x0000000000000000,
0x8000000000000000,0x0000000000008000,
0x8000000000000000,0x0000000080000000,
0x8000000000000000,0x0000000080008000,
0x8000000000000000,0x0000800000000000,
0x8000000000000000,0x0000800000008000,
0x8000000000000000,0x0000800080000000,
0x8000000000000000,0x0000800080008000,
0x8000000000000000,0x8000000000000000,
0x8000000000000000,0x8000000000008000,
0x8000000000000000,0x8000000080000000,
0x8000000000000000,0x8000000080008000,
0x8000000000000000,0x8000800000000000,
0x8000000000000000,0x8000800000008000,
0x8000000000000000,0x8000800080000000,
0x8000000000000000,0x8000800080008000,
0x8000000000008000,0x0000000000000000,
0x8000000000008000,0x0000000000008000,
0x8000000000008000,0x0000000080000000,
0x8000000000008000,0x0000000080008000,
0x8000000000008000,0x0000800000000000,
0x8000000000008000,0x0000800000008000,
0x8000000000008000,0x0000800080000000,
0x8000000000008000,0x0000800080008000,
0x8000000000008000,0x8000000000000000,
0x8000000000008000,0x8000000000008000,
0x8000000000008000,0x8000000080000000,
0x8000000000008000,0x8000000080008000,
0x8000000000008000,0x8000800000000000,
0x8000000000008000,0x8000800000008000,
0x8000000000008000,0x8000800080000000,
0x8000000000008000,0x8000800080008000,
0x8000000080000000,0x0000000000000000,
0x8000000080000000,0x0000000000008000,
0x8000000080000000,0x0000000080000000,
0x8000000080000000,0x0000000080008000,
0x8000000080000000,0x0000800000000000,
0x8000000080000000,0x0000800000008000,
0x8000000080000000,0x0000800080000000,
0x8000000080000000,0x0000800080008000,
0x8000000080000000,0x8000000000000000,
0x8000000080000000,0x8000000000008000,
0x8000000080000000,0x8000000080000000,
0x8000000080000000,0x8000000080008000,
0x8000000080000000,0x8000800000000000,
0x8000000080000000,0x8000800000008000,
0x8000000080000000,0x8000800080000000,
0x8000000080000000,0x8000800080008000,
0x8000000080008000,0x0000000000000000,
0x8000000080008000,0x0000000000008000,
0x8000000080008000,0x0000000080000000,
0x8000000080008000,0x0000000080008000,
0x8000000080008000,0x0000800000000000,
0x8000000080008000,0x0000800000008000,
0x8000000080008000,0x0000800080000000,
0x8000000080008000,0x0000800080008000,
0x8000000080008000,0x8000000000000000,
0x8000000080008000,0x8000000000008000,
0x8000000080008000,0x8000000080000000,
0x8000000080008000,0x8000000080008000,
0x8000000080008000,0x8000800000000000,
0x8000000080008000,0x8000800000008000,
0x8000000080008000,0x8000800080000000,
0x8000000080008000,0x8000800080008000,
0x8000800000000000,0x0000000000000000,
0x8000800000000000,0x0000000000008000,
0x8000800000000000,0x0000000080000000,
0x8000800000000000,0x0000000080008000,
0x8000800000000000,0x0000800000000000,
0x8000800000000000,0x0000800000008000,
0x8000800000000000,0x0000800080000000,
0x8000800000000000,0x0000800080008000,
0x8000800000000000,0x8000000000000000,
0x8000800000000000,0x8000000000008000,
0x8000800000000000,0x8000000080000000,
0x8000800000000000,0x8000000080008000,
0x8000800000000000,0x8000800000000000,
0x8000800000000000,0x8000800000008000,
0x8000800000000000,0x8000800080000000,
0x8000800000000000,0x8000800080008000,
0x8000800000008000,0x0000000000000000,
0x8000800000008000,0x0000000000008000,
0x8000800000008000,0x0000000080000000,
0x8000800000008000,0x0000000080008000,
0x8000800000008000,0x0000800000000000,
0x8000800000008000,0x0000800000008000,
0x8000800000008000,0x0000800080000000,
0x8000800000008000,0x0000800080008000,
0x8000800000008000,0x8000000000000000,
0x8000800000008000,0x8000000000008000,
0x8000800000008000,0x8000000080000000,
0x8000800000008000,0x8000000080008000,
0x8000800000008000,0x8000800000000000,
0x8000800000008000,0x8000800000008000,
0x8000800000008000,0x8000800080000000,
0x8000800000008000,0x8000800080008000,
0x8000800080000000,0x0000000000000000,
0x8000800080000000,0x0000000000008000,
0x8000800080000000,0x0000000080000000,
0x8000800080000000,0x0000000080008000,
0x8000800080000000,0x0000800000000000,
0x8000800080000000,0x0000800000008000,
0x8000800080000000,0x0000800080000000,
0x8000800080000000,0x0000800080008000,
0x8000800080000000,0x8000000000000000,
0x8000800080000000,0x8000000000008000,
0x8000800080000000,0x8000000080000000,
0x8000800080000000,0x8000000080008000,
0x8000800080000000,0x8000800000000000,
0x8000800080000000,0x8000800000008000,
0x8000800080000000,0x8000800080000000,
0x8000800080000000,0x8000800080008000,
0x8000800080008000,0x0000000000000000,
0x8000800080008000,0x0000000000008000,
0x8000800080008000,0x0000000080000000,
0x8000800080008000,0x0000000080008000,
0x8000800080008000,0x0000800000000000,
0x8000800080008000,0x0000800000008000,
0x8000800080008000,0x0000800080000000,
0x8000800080008000,0x0000800080008000,
0x8000800080008000,0x8000000000000000,
0x8000800080008000,0x8000000000008000,
0x8000800080008000,0x8000000080000000,
0x8000800080008000,0x8000000080008000,
0x8000800080008000,0x8000800000000000,
0x8000800080008000,0x8000800000008000,
0x8000800080008000,0x8000800080000000,
0x8000800080008000,0x8000800080008000,
};

void print_spbox32()
{
    cout << "uint32_t spbox32[256] =\n{\n";

    for (int i = 0; i < 256; i++)
    {
        cout << std::hex << "0x" << setfill('0') << setw(8) << pbox32[sbox[i]] << ",\n";
    }

    cout << "};\n";
}

void print_spbox64()
{
    cout << "uint64_t spbox64[256] =\n{\n";

    for (int i = 0; i < 256; i++)
    {
        cout << std::hex << "0x" << setfill('0') << setw(16) << pbox64[sbox[i]] << ",\n";
    }

    cout << "};\n";
}
//*/

uint32_t spbox32[256] =
{
0x08800088,
0x08888800,
0x08880888,
0x08888088,
0x88880080,
0x08808088,
0x08808888,
0x88000808,
0x00880000,
0x00000008,
0x08800888,
0x00808088,
0x88888880,
0x88080888,
0x80808088,
0x08880880,
0x88008080,
0x80000080,
0x88008008,
0x08888808,
0x88888080,
0x08088008,
0x08000888,
0x88880000,
0x80808808,
0x88080800,
0x80800080,
0x80808888,
0x80088800,
0x80800800,
0x08880080,
0x88000000,
0x80880888,
0x88888808,
0x80080088,
0x00800880,
0x00880880,
0x00888888,
0x88880888,
0x88008800,
0x00880800,
0x80800808,
0x88800808,
0x88880008,
0x08880008,
0x88088000,
0x00880008,
0x00080808,
0x00000800,
0x88000888,
0x00800088,
0x88000088,
0x00088000,
0x80080880,
0x00000808,
0x80088080,
0x00000888,
0x00080080,
0x80000000,
0x88800080,
0x88808088,
0x00800888,
0x80880080,
0x08880808,
0x00008008,
0x80000088,
0x00808800,
0x00088080,
0x00088088,
0x08808880,
0x08088080,
0x80800000,
0x08080080,
0x00888088,
0x88080880,
0x80880088,
0x00808008,
0x88800088,
0x00808888,
0x80000800,
0x08080088,
0x88080008,
0x00000000,
0x88808808,
0x00800000,
0x88888800,
0x80880008,
0x08088088,
0x08808080,
0x88008088,
0x80888880,
0x00888008,
0x08008080,
0x08008800,
0x08088000,
0x88008888,
0x88080000,
0x88808888,
0x80808080,
0x88888088,
0x08000088,
0x08008808,
0x00880088,
0x80000808,
0x08000808,
0x88888008,
0x00000080,
0x08888888,
0x08080000,
0x00888800,
0x80088888,
0x80808000,
0x08080008,
0x80800088,
0x08000000,
0x80008888,
0x80080080,
0x80088808,
0x00888000,
0x88880808,
0x80888800,
0x80880880,
0x88088080,
0x00800008,
0x00080000,
0x88888888,
0x88880088,
0x88080080,
0x88008808,
0x00008800,
0x00080088,
0x88808800,
0x08088888,
0x80080888,
0x08000800,
0x00080888,
0x88000800,
0x80800888,
0x08888880,
0x00888808,
0x08800800,
0x08088808,
0x00088008,
0x08880088,
0x08800000,
0x80000008,
0x08008888,
0x88088800,
0x00800080,
0x00808080,
0x80080000,
0x80008000,
0x08000880,
0x88808880,
0x80888000,
0x00080800,
0x88088880,
0x08088880,
0x00008088,
0x88088088,
0x88800000,
0x00880080,
0x00888080,
0x00008080,
0x08008008,
0x00000880,
0x00800800,
0x08088800,
0x88000080,
0x88080088,
0x80808800,
0x08800080,
0x80080008,
0x80080808,
0x88800800,
0x08888008,
0x88800888,
0x88008000,
0x00880888,
0x08808808,
0x80008808,
0x88080808,
0x08008880,
0x80808008,
0x08808800,
0x08080880,
0x88880800,
0x88808080,
0x08800808,
0x08888080,
0x80808880,
0x00008000,
0x80888080,
0x08888000,
0x00800808,
0x00808880,
0x00088800,
0x80800880,
0x80880800,
0x88000880,
0x88808000,
0x88088808,
0x08880800,
0x00088888,
0x08008088,
0x80888808,
0x80008088,
0x80008080,
0x08880000,
0x00888880,
0x80880808,
0x08800880,
0x08008000,
0x00000088,
0x88880880,
0x00008880,
0x08800008,
0x00880808,
0x08080888,
0x80888008,
0x80000880,
0x88000008,
0x00088808,
0x80088880,
0x88800008,
0x88888000,
0x80088000,
0x00080008,
0x08808008,
0x88088008,
0x80008880,
0x80080800,
0x80088088,
0x00088880,
0x80000888,
0x88808008,
0x88008880,
0x08080808,
0x00808000,
0x88088888,
0x80008800,
0x80800008,
0x80008008,
0x00008808,
0x80888888,
0x88800880,
0x08000080,
0x08808000,
0x08000008,
0x80088008,
0x00808808,
0x00008888,
0x80880000,
0x08080800,
0x80888088,
0x00080880,
};

uint64_t spbox64[256] =
{
0x0080800000008080,
0x0080808080800000,
0x0080808000808080,
0x0080808080008080,
0x8080808000008000,
0x0080800080008080,
0x0080800080808080,
0x8080000000800080,
0x0000808000000000,
0x0000000000000080,
0x0080800000808080,
0x0000800080008080,
0x8080808080808000,
0x8080008000808080,
0x8000800080008080,
0x0080808000808000,
0x8080000080008000,
0x8000000000008000,
0x8080000080000080,
0x0080808080800080,
0x8080808080008000,
0x0080008080000080,
0x0080000000808080,
0x8080808000000000,
0x8000800080800080,
0x8080008000800000,
0x8000800000008000,
0x8000800080808080,
0x8000008080800000,
0x8000800000800000,
0x0080808000008000,
0x8080000000000000,
0x8000808000808080,
0x8080808080800080,
0x8000008000008080,
0x0000800000808000,
0x0000808000808000,
0x0000808080808080,
0x8080808000808080,
0x8080000080800000,
0x0000808000800000,
0x8000800000800080,
0x8080800000800080,
0x8080808000000080,
0x0080808000000080,
0x8080008080000000,
0x0000808000000080,
0x0000008000800080,
0x0000000000800000,
0x8080000000808080,
0x0000800000008080,
0x8080000000008080,
0x0000008080000000,
0x8000008000808000,
0x0000000000800080,
0x8000008080008000,
0x0000000000808080,
0x0000008000008000,
0x8000000000000000,
0x8080800000008000,
0x8080800080008080,
0x0000800000808080,
0x8000808000008000,
0x0080808000800080,
0x0000000080000080,
0x8000000000008080,
0x0000800080800000,
0x0000008080008000,
0x0000008080008080,
0x0080800080808000,
0x0080008080008000,
0x8000800000000000,
0x0080008000008000,
0x0000808080008080,
0x8080008000808000,
0x8000808000008080,
0x0000800080000080,
0x8080800000008080,
0x0000800080808080,
0x8000000000800000,
0x0080008000008080,
0x8080008000000080,
0x0000000000000000,
0x8080800080800080,
0x0000800000000000,
0x8080808080800000,
0x8000808000000080,
0x0080008080008080,
0x0080800080008000,
0x8080000080008080,
0x8000808080808000,
0x0000808080000080,
0x0080000080008000,
0x0080000080800000,
0x0080008080000000,
0x8080000080808080,
0x8080008000000000,
0x8080800080808080,
0x8000800080008000,
0x8080808080008080,
0x0080000000008080,
0x0080000080800080,
0x0000808000008080,
0x8000000000800080,
0x0080000000800080,
0x8080808080000080,
0x0000000000008000,
0x0080808080808080,
0x0080008000000000,
0x0000808080800000,
0x8000008080808080,
0x8000800080000000,
0x0080008000000080,
0x8000800000008080,
0x0080000000000000,
0x8000000080808080,
0x8000008000008000,
0x8000008080800080,
0x0000808080000000,
0x8080808000800080,
0x8000808080800000,
0x8000808000808000,
0x8080008080008000,
0x0000800000000080,
0x0000008000000000,
0x8080808080808080,
0x8080808000008080,
0x8080008000008000,
0x8080000080800080,
0x0000000080800000,
0x0000008000008080,
0x8080800080800000,
0x0080008080808080,
0x8000008000808080,
0x0080000000800000,
0x0000008000808080,
0x8080000000800000,
0x8000800000808080,
0x0080808080808000,
0x0000808080800080,
0x0080800000800000,
0x0080008080800080,
0x0000008080000080,
0x0080808000008080,
0x0080800000000000,
0x8000000000000080,
0x0080000080808080,
0x8080008080800000,
0x0000800000008000,
0x0000800080008000,
0x8000008000000000,
0x8000000080000000,
0x0080000000808000,
0x8080800080808000,
0x8000808080000000,
0x0000008000800000,
0x8080008080808000,
0x0080008080808000,
0x0000000080008080,
0x8080008080008080,
0x8080800000000000,
0x0000808000008000,
0x0000808080008000,
0x0000000080008000,
0x0080000080000080,
0x0000000000808000,
0x0000800000800000,
0x0080008080800000,
0x8080000000008000,
0x8080008000008080,
0x8000800080800000,
0x0080800000008000,
0x8000008000000080,
0x8000008000800080,
0x8080800000800000,
0x0080808080000080,
0x8080800000808080,
0x8080000080000000,
0x0000808000808080,
0x0080800080800080,
0x8000000080800080,
0x8080008000800080,
0x0080000080808000,
0x8000800080000080,
0x0080800080800000,
0x0080008000808000,
0x8080808000800000,
0x8080800080008000,
0x0080800000800080,
0x0080808080008000,
0x8000800080808000,
0x0000000080000000,
0x8000808080008000,
0x0080808080000000,
0x0000800000800080,
0x0000800080808000,
0x0000008080800000,
0x8000800000808000,
0x8000808000800000,
0x8080000000808000,
0x8080800080000000,
0x8080008080800080,
0x0080808000800000,
0x0000008080808080,
0x0080000080008080,
0x8000808080800080,
0x8000000080008080,
0x8000000080008000,
0x0080808000000000,
0x0000808080808000,
0x8000808000800080,
0x0080800000808000,
0x0080000080000000,
0x0000000000008080,
0x8080808000808000,
0x0000000080808000,
0x0080800000000080,
0x0000808000800080,
0x0080008000808080,
0x8000808080000080,
0x8000000000808000,
0x8080000000000080,
0x0000008080800080,
0x8000008080808000,
0x8080800000000080,
0x8080808080000000,
0x8000008080000000,
0x0000008000000080,
0x0080800080000080,
0x8080008080000080,
0x8000000080808000,
0x8000008000800000,
0x8000008080008080,
0x0000008080808000,
0x8000000000808080,
0x8080800080000080,
0x8080000080808000,
0x0080008000800080,
0x0000800080000000,
0x8080008080808080,
0x8000000080800000,
0x8000800000000080,
0x8000000080000080,
0x0000000080800080,
0x8000808080808080,
0x8080800000808000,
0x0080000000008000,
0x0080800080000000,
0x0080000000000080,
0x8000008080000080,
0x0000800080800080,
0x0000000080808080,
0x8000808000000000,
0x0080008000800000,
0x8000808080008080,
0x0000008000808000,
};

uint32_t PIEhash(uint32_t* data, uint32_t count)
{
    uint32_t multi = 0x3CBEC79D; // From: https://www.pcg-random.org/posts/does-it-beat-the-minimal-standard.html.
    uint32_t state = 0x3243f6a8; // First digits of PI.
    uint32_t value = 0x2b7e1516; // First digits of e.
    uint8_t* bytes = reinterpret_cast<uint8_t*>(&value);

    auto lookup = [&](int index)
    {
        return spbox32[bytes[index]] >> (3 - index);
    };

    auto permute = [&]()
    {
        return lookup(3) | lookup(2) | lookup(1) | lookup(0);
    };

    // Apply one round per block of data.
    for (uint32_t i = 0; i < count; i++)
    {
        value ^= (data[i] + state); // XOR in data + state.
        value = permute();
        state = state * multi + 1; // Update LCG.
    }

    // Apply final round.
    value ^= state; // XOR in state.
    value = permute();

    return value;
}

uint64_t PIEhash(uint64_t* data, uint64_t count)
{
    uint64_t multi = 0x7FACC0F7A00541BD; // From: https://www.pcg-random.org/posts/does-it-beat-the-minimal-standard.html.
    uint64_t state = 0x3243f6a8885a308d; // First digits of PI.
    uint64_t value = 0x2b7e151628aed2a6; // First digits of e.
    uint8_t* bytes = reinterpret_cast<uint8_t*>(&value);

    auto lookup = [&](int index)
    {
        return spbox64[bytes[index]] >> (7 - index);
    };

    auto permute = [&]()
    {
        return lookup(7) | lookup(6) | lookup(5) | lookup(4) | lookup(3) | lookup(2) | lookup(1) | lookup(0);
    };

    // Apply one round per block of data.
    for (uint64_t i = 0; i < count; i++)
    {
        value ^= (data[i] + state); // XOR in data + state.
        value = permute();
        state = state * multi + 1; // Update LCG.
    }

    // Apply final round.
    value ^= state; // XOR in state.
    value = permute();

    return value;
}

/*
uint32_t permute(uint32_t data)
{
    uint8_t* tmp = reinterpret_cast<uint8_t*>(&data);

    return (pbox32[sbox[tmp[0]]]) | (pbox32[sbox[tmp[1]]] >> 1) | (pbox32[sbox[tmp[2]]] >> 2) | (pbox32[sbox[tmp[3]]] >> 3);
}
//*/

__m256i flood_fill_step(__m256i value)
{
    __m256i srli_mask = _mm256_set_epi64x(0xFFFEFFFEFFFEFFFE, 0xFFFEFFFEFFFEFFFE, 0xFFFEFFFEFFFEFFFE, 0xFFFEFFFEFFFEFFFE);
    __m256i slli_mask = _mm256_set_epi64x(0x7FFF7FFF7FFF7FFF, 0x7FFF7FFF7FFF7FFF, 0x7FFF7FFF7FFF7FFF, 0x7FFF7FFF7FFF7FFF);

    __m256i val_a = _mm256_and_si256(value, srli_mask);
    __m256i tmp01 = _mm256_srli_epi64(val_a, 1);
    __m256i tmp02 = _mm256_slli_epi64(val_a, 63);
    tmp02 = _mm256_permute4x64_epi64(tmp02, 0x93);
    tmp02 = _mm256_insert_epi64(tmp02, 0, 0);
    __m256i tmp03 = _mm256_or_si256(tmp01, tmp02);

    __m256i val_b = _mm256_and_si256(value, srli_mask);
    __m256i tmp04 = _mm256_slli_epi64(val_b, 1);
    __m256i tmp05 = _mm256_srli_epi64(val_b, 63);
    tmp05 = _mm256_permute4x64_epi64(tmp05, 0x39);
    tmp05 = _mm256_insert_epi64(tmp05, 0, 3);
    __m256i tmp06 = _mm256_or_si256(tmp04, tmp05);
    tmp06 = _mm256_and_si256(tmp06, srli_mask);

    __m256i tmp06a = _mm256_or_si256(tmp03, tmp06);
    __m256i tmp06b = _mm256_or_si256(value, tmp06a);

    __m256i tmp07 = _mm256_srli_epi64(tmp06b, 16);
    __m256i tmp08 = _mm256_slli_epi64(tmp06b, 48);
    tmp08 = _mm256_permute4x64_epi64(tmp08, 0x93);
    tmp08 = _mm256_insert_epi64(tmp08, 0, 0);
    __m256i tmp09 = _mm256_or_si256(tmp07, tmp08);

    __m256i tmp10 = _mm256_slli_epi64(tmp06b, 16);
    __m256i tmp11 = _mm256_srli_epi64(tmp06b, 48);
    tmp11 = _mm256_permute4x64_epi64(tmp11, 0x39);
    tmp11 = _mm256_insert_epi64(tmp11, 0, 3);
    __m256i tmp12 = _mm256_or_si256(tmp10, tmp11);

    __m256i tmp12a = _mm256_or_si256(tmp09, tmp12);
    __m256i tmp12b = _mm256_or_si256(tmp06b, tmp12a);

    return tmp12b;
}


__m256i rotr(__m256i value, uint8_t n)
{
    __m256i tmp1 = _mm256_srli_epi64(value, n);
    __m256i tmp2 = _mm256_slli_epi64(value, 64 - n);
    tmp2 = _mm256_permute4x64_epi64(tmp2, 0x93);
    return _mm256_or_si256(tmp1, tmp2);
}

__m256i srl(__m256i value, uint8_t n)
{
    __m256i tmp1 = _mm256_srli_epi64(value, n);
    __m256i tmp2 = _mm256_slli_epi64(value, 64 - n);
    tmp2 = _mm256_permute4x64_epi64(tmp2, 0x93);
    tmp2 = _mm256_insert_epi64(tmp2, 0, 0);
    return _mm256_or_si256(tmp1, tmp2);
}

__m256i rotl(__m256i value, uint8_t n)
{
    __m256i tmp1 = _mm256_slli_epi64(value, n);
    __m256i tmp2 = _mm256_srli_epi64(value, 64 - n);
    tmp2 = _mm256_permute4x64_epi64(tmp2, 0x39);
    return _mm256_or_si256(tmp1, tmp2);
}

__m256i sll(__m256i value, uint8_t n)
{
    __m256i tmp1 = _mm256_slli_epi64(value, n);
    __m256i tmp2 = _mm256_srli_epi64(value, 64 - n);
    tmp2 = _mm256_permute4x64_epi64(tmp2, 0x39);
    tmp2 = _mm256_insert_epi64(tmp2, 0, 3);
    return _mm256_or_si256(tmp1, tmp2);
}

void test_shift256()
{
    __m256i value, value2, tmp;

    value = _mm256_set_epi64x(0xFEDCBA9876543210, 0x76543210FEDCBA98, 0x89ABCDEF01234567, 0x0123456789ABCDEF);
    value2 = _mm256_set_epi64x(0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x000000007FFE0000);

    tmp = flood_fill_step(value2);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);
    tmp = flood_fill_step(tmp);

    tmp = srl(value, 4);
    tmp = srl(value, 8);
    tmp = srl(value, 12);
    tmp = srl(value, 16);

    tmp = sll(value, 4);
    tmp = sll(value, 8);
    tmp = sll(value, 12);
    tmp = sll(value, 16);
}

void test()
{
    test_shift256();
    array<uint32_t, 8> pd32 = { 0x7d1f4500, 0x72ff8c22, 0x5ccc183e, 0xb2216f55, 0xcab28e49, 0xc0de5b14, 0x3be938a2, 0x7cd8c208 };
    array<uint64_t, 8> pd64 = { 0x634516909d75739c, 0xb03faf442977a812, 0x6cb32015faf6c6cc, 0x864b3c5605a7abf9, 0x04d3c108195bbeb6, 0xb692fdf8594dd51c, 0x9b3ec4f46aceb387, 0xad3a585c9159fc1e };
    //array<uint64_t, 8> pd64 = { 0, 0, 0, 0, 0, 0, 0, 0 };

    uint32_t result = 0;
    result = PIEhash(pd32.data(), pd32.size());

    uint64_t result64 = 0;
    result64 = PIEhash(pd64.data(), pd64.size());

    /*
    result = 0;
    result = permute(0x7d1f4500);
    result = permute(result);
    result = permute(0x7d1f4501);
    result = permute(result);
    result = permute(0x7d1f4502);
    result = permute(result);
    result = permute(0x7d1f4504);
    result = permute(result);
    //*/
}

struct TestingParams
{
    std::string input_filename = "in.bin";
    std::string output_filename = "out.bin2";
    int test = 0;

    void enforce_constraints()
    {
        // TODO.
    }
};

namespace Stockfish
{
    void is_supermajor()
    {
        StateListPtr states(new std::deque<StateInfo>(1));
        Position pos;
        Color us = BLACK;
        Color them = ~us;
        bool is_checkmate = false;
        Bitboard checkersBB = 0;
        Bitboard us_BB = 0;
        Bitboard them_BB = 0;
        Bitboard attackers_BB = 0;
        int move_count = 0;
        const Variant* v = variants.find(Options["UCI_Variant"])->second;
        int checkmate_count = 0, stalemate_count = 0, notmate_count = 0;
        int16_t result[64][64] = { -1 };

        std::memset(&result,-1,sizeof(result[0][0])*64*64);

        for (Piece pc = W_PAWN; pc < W_KING; ++pc)
        {
            if ( v->pieceToChar[pc] == ' ' )
                continue;

            checkmate_count = stalemate_count = notmate_count = 0;

            for (Square bk_sq = SQ_A1; bk_sq <= SQ_MAX; ++bk_sq)
            {
                for (Square pc_sq = SQ_A1; pc_sq <= SQ_MAX; ++pc_sq)
                {
                    if (pc_sq == bk_sq)
                        continue;

                    StateInfo si;
                    PosCodecHelper hlp(&pos, &si, v);

                    pos.put_piece(B_KING, bk_sq);
                    pos.put_piece(pc, pc_sq);

                    hlp.side_to_move(us);
                    hlp.set_state();

                    us_BB = pos.pieces(us);
                    them_BB = pos.pieces(them);
                    attackers_BB = pos.attackers_to(bk_sq, us_BB | them_BB);
                    checkersBB = attackers_BB & them_BB;

                    MoveList<LEGAL> moves = MoveList<LEGAL>(pos);
                    move_count = moves.size();

                    if (move_count == 0)
                    {
                        if (pos.checkers())
                        {
                            checkmate_count++;
                            result[bk_sq][pc_sq] = 0;
                            sync_cout << pos << sync_endl;
                        }
                        else
                        {
                            stalemate_count++;
                            //sync_cout << pos << sync_endl;

                        }
                    }
                    else
                    {
                        notmate_count++;
                    }
                }
            }

            sync_cout << "{index:" << pc << ",piece:" << v->pieceNotation[pc] << ",checkmate:" << checkmate_count << ",stalemate:" << stalemate_count << ",notmate:" << notmate_count << ",total:" << (checkmate_count + stalemate_count + notmate_count) << "}" << sync_endl;
        }
    }

    void can_checkmate(Piece pc1, Piece pc2)
    {
        StateListPtr states(new std::deque<StateInfo>(1));
        Position pos;
        Color us = BLACK;
        Color them = ~us;
        bool is_checkmate = false;
        Bitboard checkersBB = 0;
        Bitboard us_BB = 0;
        Bitboard them_BB = 0;
        Bitboard attackers_BB = 0;
        Bitboard bk_attackers = 0;
        Bitboard wk_attackers = 0;
        Value result;
        int move_count = 0;
        const Variant* v = variants.find(Options["UCI_Variant"])->second;
        int checkmate_count = 0, stalemate_count = 0, notmate_count = 0, illegal_count = 0;

        for (Square bk_sq = SQ_A1; bk_sq <= SQ_MAX; ++bk_sq)
        {
            for (Square wk_sq = SQ_A1; wk_sq <= SQ_MAX; ++wk_sq)
            {
                if (wk_sq == bk_sq)
                    continue;

                for (Square pc1_sq = SQ_A1; pc1_sq <= SQ_MAX; ++pc1_sq)
                {
                    if (pc1_sq == bk_sq || pc1_sq == wk_sq)
                        continue;

                    for (Square pc2_sq = SQ_A1; pc2_sq <= SQ_MAX; ++pc2_sq)
                    {
                        if (pc2_sq == bk_sq || pc2_sq == wk_sq || pc2_sq == pc1_sq)
                            continue;

                        StateInfo si;
                        PosCodecHelper hlp(&pos, &si, v);

                        pos.put_piece(B_KING, bk_sq);
                        pos.put_piece(W_KING, wk_sq);

                        // Make sure kings aren't next to each other.
                        us_BB = pos.pieces(us);
                        them_BB = pos.pieces(them);
                        bk_attackers = pos.attackers_to(bk_sq, us_BB | them_BB);
                        wk_attackers = pos.attackers_to(wk_sq, us_BB | them_BB);

                        if (bk_attackers && wk_attackers)
                        {
                            illegal_count++;
                            continue;
                        }

                        if (!pos.empty(pc1_sq)|| !pos.empty(pc2_sq))
                            continue;

                        pos.put_piece(pc1, pc1_sq);
                        pos.put_piece(pc2, pc2_sq);

                        hlp.side_to_move(us);
                        hlp.set_state();

                        //sync_cout << pos << sync_endl;

                        MoveList<LEGAL> moves = MoveList<LEGAL>(pos);
                        move_count = moves.size();

                        if (move_count == 0)
                        {
                            if (pos.checkers())
                            {
                                checkmate_count++;
                                sync_cout << pos << sync_endl;
                            }
                            else
                            {
                                stalemate_count++;

                            }
                        }
                        else
                        {
                            notmate_count++;
                        }
                    }
                }
            }
        }

        sync_cout << "{piece1:" << v->pieceNotation[pc1] << ",piece2:" << v->pieceNotation[pc2] << ",checkmate:" << checkmate_count << ",stalemate:" << stalemate_count << ",notmate:" << notmate_count << ",illegal:" << illegal_count << ",total:" << (checkmate_count + stalemate_count + notmate_count + illegal_count) << " }" << sync_endl;
    }

    void is_major()
    {
        StateListPtr states(new std::deque<StateInfo>(1));
        Position pos;
        Color us = BLACK;
        Color them = ~us;
        bool is_checkmate = false;
        Bitboard checkersBB = 0;
        Bitboard us_BB = 0;
        Bitboard them_BB = 0;
        Bitboard attackers_BB = 0;
        Bitboard bk_attackers = 0;
        Bitboard wk_attackers = 0;
        Value result;
        int move_count = 0;
        const Variant* v = variants.find(Options["UCI_Variant"])->second;
        int checkmate_count = 0, stalemate_count = 0, notmate_count = 0, illegal_count = 0;

        for (Piece pc = W_PAWN; pc < W_KING; ++pc)
        {
            if (v->pieceToChar[pc] == ' ')
                continue;

            checkmate_count = stalemate_count = notmate_count = illegal_count = 0;

            for (Square bk_sq = SQ_A1; bk_sq <= SQ_MAX; ++bk_sq)
            {
                for (Square wk_sq = SQ_A1; wk_sq <= SQ_MAX; ++wk_sq)
                {
                    if (wk_sq == bk_sq)
                        continue;

                    for (Square pc_sq = SQ_A1; pc_sq <= SQ_MAX; ++pc_sq)
                    {
                        if (pc_sq == bk_sq || pc_sq == wk_sq)
                            continue;

                        StateInfo si;
                        PosCodecHelper hlp(&pos, &si, v);

                        pos.put_piece(B_KING, bk_sq);
                        pos.put_piece(W_KING, wk_sq);

                        // Make sure kings aren't next to each other.
                        us_BB = pos.pieces(us);
                        them_BB = pos.pieces(them);
                        bk_attackers = pos.attackers_to(bk_sq, us_BB | them_BB);
                        wk_attackers = pos.attackers_to(wk_sq, us_BB | them_BB);

                        if (bk_attackers && wk_attackers)
                        {
                            illegal_count++;
                            continue;
                        }

                        if (!pos.empty(pc_sq))
                            continue;

                        pos.put_piece(pc, pc_sq);

                        hlp.side_to_move(us);
                        hlp.set_state();

                        MoveList<LEGAL> moves = MoveList<LEGAL>(pos);
                        move_count = moves.size();

                        if (move_count == 0)
                        {
                            if (pos.checkers())
                            {
                                checkmate_count++;
                            }
                            else
                            {
                                stalemate_count++;

                            }

                            //sync_cout << pos << sync_endl;
                        }
                        else
                        {
                            notmate_count++;
                        }
                    }
                }
            }

            sync_cout << "{index:" << pc << ",piece:" << v->pieceNotation[pc] << ",checkmate:" << checkmate_count << ",stalemate:" << stalemate_count << ",notmate:" << notmate_count << ",illegal:" << illegal_count << ",total:" << (checkmate_count + stalemate_count + notmate_count + illegal_count) << "}" << sync_endl;
        }
    }

    void enumeratePieces()
    {
        Position pos;
        Piece p1 = W_ROOK, p2 = B_QUEEN;

        for (Square wksq = SQ_A1; wksq < SQ_MAX; ++wksq)
        {
            pos.clear();
            pos.put_piece(W_KING, (Square)wksq);

            for (Square bksq = SQ_A1; bksq < SQ_MAX; ++bksq)
            {
                if ( pos.empty((Square)bksq) )
                    continue;

                pos.put_piece(B_KING, (Square)bksq);

                for (Square p1sq = SQ_A1; p1sq < SQ_MAX; ++p1sq)
                {
                    if (pos.empty((Square)p1sq))
                        continue;

                    pos.put_piece(p1, (Square)p1sq);

                    for (Square p2sq = SQ_A1; p2sq < SQ_MAX; ++p2sq)
                    {
                        if (pos.empty((Square)p2sq))
                            continue;

                        pos.put_piece(p2, (Square)p2sq);

                        // Should now have four pieces on the board, check to see if it's a legal position.
                        // if ( !pos.is_legal() )
                        //   continue;

                        // Probe EGTB for result.

                        // Write position to file for training data?

                    }
                }
            }
        }
    }
}

void testParse();

void _testing(std::istringstream& is)
{
    TestingParams params{};

    while (true)
    {
        std::string token, piece;
        is >> token;

        if (token == "")
            break;

        if (token == "-t" || token == "--test")
            is >> params.test;
        else if (token == "-i" || token == "input_file")
            is >> params.input_filename;
        else if (token == "-o" || token == "output_file")
            is >> params.output_filename;
        else if (token == "-parse")
            testParse();
        else if (token == "-supermajor")
        {
            Stockfish::is_supermajor();
        }
        else if (token == "-major")
        {
            Stockfish::is_major();
        }
        else if (token == "-twopc")
        {
            //is >> piece;
            //Stockfish::is_major(Stockfish::make_piece(Stockfish::WHITE, (Stockfish::PieceType)std::stoi(piece)));
            Stockfish::can_checkmate(Stockfish::make_piece(Stockfish::WHITE, Stockfish::BISHOP), Stockfish::make_piece(Stockfish::WHITE, Stockfish::KNIGHT));
        }
        /*
        else if (token == "-spbox32")
            print_spbox32();
        else if (token == "-spbox64")
            print_spbox64();
        //*/
        else if (token == "-piehash")
            test();
        else
        {
            cout << "ERROR: Unknown option " << token << ". Exiting...\n";
            return;
        }
    }

    params.enforce_constraints();

    //cout << "Performing _testing with parameters:\n";
    //cout << "input_file          : " << params.input_filename << '\n';
    //cout << "output_file         : " << params.output_filename << '\n';
    //cout << '\n';

    //do_extract(params);
}

enum TokenType
{
    END,
    OBJECT_OPEN,
    OBJECT_CLOSE,
    ARRAY_OPEN,
    ARRAY_CLOSE,
    COLON,
    COMMA,
    STRING,
    IDENTIFIER,
    NUMBER,
    TRUE_LITERAL,
    FALSE_LITERAL,
    NULL_LITERAL,
};

class Value
{
public:
    string m_token;
};

struct Token
{
    TokenType m_type;
    string m_str;
    Value* m_value;
};

class Identifier
{
public:
    Identifier(const Token& t)
    {
        if (t.m_type == IDENTIFIER)
        {
            m_token = t.m_str;
        }
        else
        {
            // ERROR: token passed in wasn't an IDENTIFIER.
            assert(false);
        }
    }

    bool operator<(const Identifier& rhs) const
    {
        return (m_token < rhs.m_token);
    }

    bool operator==(const Identifier& rhs) const
    {
        return (m_token == rhs.m_token);
    }

    string m_token;
};

class IdentifierCompare
{
public:
    bool operator()(const Identifier& lhs, const Identifier& rhs) const
    {
        return (lhs == rhs);
    }
};

class Object : public Value
{
public:
    map<string,Value*> m_members;

    void add(const Token* key, const Token* val)
    {
        m_members.insert_or_assign(key->m_str, val->m_value);
    }

    Value* operator[](const string& v) { return m_members.at(v); }
};

class Array : public Value
{
public:
    vector<Value*> m_array;
};

class String : public Value
{
public:
    String(const Token& t)
    {
        if (t.m_type == STRING)
        {
            m_token = t.m_str;
        }
        else
        {
            // ERROR: token passed in wasn't an IDENTIFIER.
            assert(false);
        }
    }
};

class Number : public Value
{
public:
    Number(const Token& t)
    {
        if (t.m_type == NUMBER)
        {
            m_token = t.m_str;
        }
        else
        {
            // ERROR: token passed in wasn't an IDENTIFIER.
            assert(false);
        }
    }
};


class TrueLiteral : public Value
{
public:
    TrueLiteral() { m_token = "true"; }
};

class FalseLiteral : public Value
{
public:
    FalseLiteral() { m_token = "false"; }
};

class NullLiteral : public Value
{
public:
    NullLiteral() { m_token = "null"; }
};

class Parser
{
public:
    stringstream* m_stream;
    Object* m_root = nullptr;
    int m_line;
    int read_pos;
    vector<Token> tokens;

    Parser(stringstream* stream)
        :m_line(1), m_stream( stream ), read_pos(0)
    { }

    Token readToken()
    {
        Token ret;
        char c;
        char cbuf[64];
        stringstream ss;

        skipWhitespace();

        if (m_stream->eof())
        {
            ret.m_type = END;
            ret.m_str = "";
        }
        else
        {
            c = m_stream->get();

            switch ( c )
            {
            case '{':
                ret.m_type = OBJECT_OPEN;
                ret.m_str = "{";
                break;
            case '}':
                ret.m_type = OBJECT_CLOSE;
                ret.m_str = "}";
                break;
            case '[':
                ret.m_type = ARRAY_OPEN;
                ret.m_str = "[";
                break;
            case ']':
                ret.m_type = ARRAY_CLOSE;
                ret.m_str = "]";
                break;
            case ',':
                ret.m_type = COMMA;
                ret.m_str = ",";
                break;
            case ':':
                ret.m_type = COLON;
                ret.m_str = ":";
                break;
            default:
                // String
                if (c == '"')
                {
                    ret.m_type = STRING;

                    while (true)
                    {
                        c = m_stream->peek();

                        if (c == '"')
                        {
                            m_stream->get();
                            break;
                        }

                        m_stream->get(cbuf, 64, '"');

                        ss << cbuf;
                    }

                    ret.m_str = ss.str();
                }
                // Identifier, true, false, null.
                else if (isalpha(c))
                {
                    ss << c;

                    while (true)
                    {
                        c = m_stream->peek();

                        if (!isalnum(c))
                            break;

                        c = m_stream->get();

                        ss << c;
                    }

                    ret.m_str = ss.str();

                    if (ret.m_str == "true")
                    {
                        ret.m_type = TRUE_LITERAL;
                    }
                    else if (ret.m_str == "false")
                    {
                        ret.m_type = FALSE_LITERAL;
                    }
                    else if (ret.m_str == "null")
                    {
                        ret.m_type = NULL_LITERAL;
                    }
                    else
                    {
                        ret.m_type = IDENTIFIER;
                    }
                }
                // Number
                else if (isdigit(c))
                {
                    ret.m_type = NUMBER;
                    ss << c;

                    while ( true )
                    {
                        c = m_stream->peek();

                        if (!isdigit(c))
                            break;

                        c = m_stream->get();

                        ss << c;
                    }

                    ret.m_str = ss.str();
                }
            }
        }

        return ret;
    }

    char readChar()
    {
        skipWhitespace();

        return m_stream->get();
    }

    void skipWhitespace()
    {
        char c;

        while ( true )
        {
            c = m_stream->peek();

            if (!isspace(c))
                break;

            c = m_stream->get();

            if (c == '\n') m_line++;
        }
    }

    Object* parseObject()
    {
        Object* ret = nullptr;
        char c;

        Token t = readToken();

        switch ( t.m_type )
        {
        case OBJECT_CLOSE:
            cout << t.m_str;
            break;
        case IDENTIFIER:
            cout << t.m_str;
            break;

        }

        return ret;
    }

    Identifier* parseIdentifier()
    {
        Identifier* ret = nullptr;
        char c;
        std:stringstream ss;

        skipWhitespace();

        c = m_stream->get();

        if (isalpha(c))
        {
            ss << c;

            while (isalnum(c = m_stream->get()))
            {
                ss << c;
            }
        }
        else
        {
            // ERROR.
        }

        return ret;
    }


    Value* parseArray()
    {
        Value* ret = nullptr;

        return ret;
    }

    Value* parseString()
    {
        Value* ret = nullptr;

        skipWhitespace();

        return ret;
    }

    Value* parseMembers()
    {
        Value* ret = nullptr;
        Token t;

        t = readToken();



        return ret;
    }

    void parse()
    {

    }

    Value* parseValue()
    {
        Value* ret = nullptr;

        return ret;
    }

    void tokenise()
    {
        Token t;
        bool end_of_tokens = false;

        while ( !end_of_tokens )
        {
            t = readToken();
            tokens.push_back(t);

            switch (t.m_type)
            {
            case OBJECT_OPEN:
                cout << "{type:OBJECT_OPEN,value:\"" << t.m_str << "\"}\n";
                break;
            case OBJECT_CLOSE:
                cout << "{type:OBJECT_CLOSE,value:\"" << t.m_str << "\"}\n";
                break;
            case ARRAY_OPEN:
                cout << "{type:ARRAY_OPEN,value:\"" << t.m_str << "\"}\n";
                break;
            case ARRAY_CLOSE:
                cout << "{type:ARRAY_CLOSE,value:\"" << t.m_str << "\"}\n";
                break;
            case STRING:
                cout << "{type:STRING,value:\"" << t.m_str << "\"}\n";
                break;
            case IDENTIFIER:
                cout << "{type:IDENTIFIER,value:\"" << t.m_str << "\"}\n";
                break;
            case NUMBER:
                cout << "{type:NUMBER,value:\"" << t.m_str << "\"}\n";
                break;
            case COMMA:
                cout << "{type:COMMA,value:\"" << t.m_str << "\"}\n";
                break;
            case COLON:
                cout << "{type:COLON,value:\"" << t.m_str << "\"}\n";
                break;
            case TRUE_LITERAL:
                cout << "{type:TRUE_LITERAL,value:\"" << t.m_str << "\"}\n";
                break;
            case FALSE_LITERAL:
                cout << "{type:FALSE_LITERAL,value:\"" << t.m_str << "\"}\n";
                break;
            case NULL_LITERAL:
                cout << "{type:NULL_LITERAL,value:\"" << t.m_str << "\"}\n";
                break;
            case END:
                cout << "{type:END,value:\"" << t.m_str << "\"}\n";
                end_of_tokens = true;
                break;
            }
        }
    }

    Object* root()
    {
        return m_root;
    }

    void parsing()
    {
        int pos = 0;
        Token* t_curr = nullptr;
        Value* v_curr = nullptr;
        Object* o_curr = nullptr;
        stack<Object*> o_stack;
        bool building_object = false;
        bool building_array = false;
        bool is_end = false;

        while (!is_end)
        {
            t_curr = &tokens[pos];

            switch (t_curr->m_type)
            {
            case END:
                is_end = true;
                pos++;
                break;
            case COMMA:
                pos++;
                break;
            case OBJECT_OPEN:
                o_curr = new Object();
                o_stack.push(o_curr);
                if (m_root == nullptr) m_root = o_curr;
                building_object = true;
                pos++;
                break;
            case OBJECT_CLOSE:
                if (!o_stack.empty())
                {
                    o_curr = o_stack.top();
                    o_stack.pop();
                }
                else
                {
                  building_object = false;
                }
                pos++;
                break;
            case IDENTIFIER:
                if (building_object)
                {
                    Token* t_colon = &tokens[pos+1];
                    Token* t_val = nullptr;

                    if (t_colon->m_type == COLON )
                    {
                        t_val = &tokens[pos+2];
                        switch (t_val->m_type)
                        {
                        case STRING:
                            t_val->m_value = new String(*t_val);
                            break;
                        case NUMBER:
                            t_val->m_value = new Number(*t_val);
                            break;
                        case ARRAY_OPEN:
                            t_val->m_value = new Array();
                            break;
                        case OBJECT_OPEN:
                            t_val->m_value = new Object();
                            o_stack.push(reinterpret_cast<Object*>(t_val->m_value));
                            break;
                        case TRUE_LITERAL:
                            t_val->m_value = new TrueLiteral();
                            break;
                        case FALSE_LITERAL:
                            t_val->m_value = new FalseLiteral();
                            break;
                        case NULL_LITERAL:
                            t_val->m_value = new NullLiteral();
                            break;
                        }

                        o_curr->add(t_curr, t_val);
                        o_curr = o_stack.top();
                    }
                    else
                    {
                        // ERROR: expected a colon, but didn't get one.
                    }
                    pos+=3;
                }
                break;
            }

        }
    }
};

class compare_1
{
public:
    bool operator()(const int lhs, const int rhs) const
    {
        return true;
    }
};

void testParse()
{
    //stringstream ss( R"({string:"teststring",header:1234,footer:5678,object:{k1:12,k2:34},array:[true,false,null,78,90]})" );
    //stringstream ss(R"({string:"teststring",header:1234,footer:5678,object:{k1:12,k2:34},array:[true,false,null,78,90]})");
    //stringstream ss(R"({variant:"chess",files:8,ranks:8,piecetypes:12,kingtypes:[0,8],pieces:[[0,"K"],[1,"P"],[2,"N"],[3,"B"],[4,"R"],[5,"Q"],[8,"k"],[9,"p"],[A,"n"],[B,"b"],[C,"r"],[D,"q"]]})");
    stringstream ss(R"({int1:1,object1:{int2:2,object2:{int3:3}}})");
    Parser p(&ss);
    Value* val;
    string temp;
    Value* tmp;

    p.tokenise();
    p.parsing();
    Object& root = *p.root();
    cout << root["int1"]->m_token << "\n";
    cout << root["object1"]->m_token << "\n";
}
